一、爬山法簡介

爬山法（climbing method）是一種優化演算法，其一般從一個隨機的解開始，然後逐步找到一個最優解（區域性最優）。 假定所求問題有多個引數，我們在通過爬山法逐步獲得最優解的過程中可以依次分別將某個引數的值增加或者減少一個單位。例如某個問題的解需要使用3個整數型別的引數x1、x2、x3，開始時將這三個引數設值為(2,2,-2)，將x1增加/減少1，得到兩個解(1,2,-2), (3, 2,-2)；將x2增加/減少1，得到兩個解(2,3, -2)，(2,1, -2)；將x3增加/減少1，得到兩個解(2,2,-1)，(2,2,-3)，這樣就得到了一個解集：
(2,2,-2), (1, 2,-2), (3, 2,-2), (2,3,-2), (2,1,-2), (2,2,-1), (2,2,-3)
從上面的解集中找到最優解，然後將這個最優解依據上面的方法再構造一個解集，再求最優解，就這樣，直到前一次的最優解和後一次的最優解相同才結束“爬山”。

二、Python例項

設方程 y = x1 x2-x3，x1是區間[-2, 5]中的整數，x2是區間[2, 6]中的整數，x3是區間[-5, 2]中的整數。使用爬山法，找到使得y取值最小的解。

程式碼：

import random

def evaluate(x1, x2, x3):
    return x1+x2-x3
#設定欲求最佳解算式
if __name__ == ‘__main__’:
    x_range = [ [-2, 5], [2, 6], [-5, 2] ]
    best_sol = [random.randint(x_range[0][0], x_range[0][1]),
           random.randint(x_range[1][0], x_range[1][1]),
           random.randint(x_range[2][0], x_range[2][1])]
#設定爬山範圍

    while True:
        best_evaluate = evaluate(best_sol[0], best_sol[1], best_sol[2])
        current_best_value = best_evaluate
        sols = [best_sol]
#設定爬山目標
        for i in xrange(len(best_sol)):
            if best_sol[i] > x_range[i][0]:
                sols.append(best_sol[0:i] [best_sol[i]-1] best_sol[i 1:])
            if best_sol[i] < x_range[i][1]:
                sols.append(best_sol[0:i] [best_sol[i] 1] best_sol[i 1:])
        print sols
#設定爬山方式
        for s in sols:
            el = evaluate(s[0], s[1], s[2])
            if el < best_evaluate:
                best_sol = s
                best_evaluate = el
        if best_evaluate == current_best_value:
            break
#設定確認爬山終點方式

    print ‘best sol：’, current_best_value, best_sol
#印出結果
   
某次執行結果如下：

[[0, 5, 1], [-1, 5, 1], [1, 5, 1], [0, 4, 1], [0, 6, 1], [0, 5, 0], [0, 5, 2]]
[[-1, 5, 1], [-2, 5, 1], [0, 5, 1], [-1, 4, 1], [-1, 6, 1], [-1, 5, 0], [-1, 5, 2]]
[[-2, 5, 1], [-1, 5, 1], [-2, 4, 1], [-2, 6, 1], [-2, 5, 0], [-2, 5, 2]]
[[-2, 4, 1], [-1, 4, 1], [-2, 3, 1], [-2, 5, 1], [-2, 4, 0], [-2, 4, 2]]
[[-2, 3, 1], [-1, 3, 1], [-2, 2, 1], [-2, 4, 1], [-2, 3, 0], [-2, 3, 2]]
[[-2, 2, 1], [-1, 2, 1], [-2, 3, 1], [-2, 2, 0], [-2, 2, 2]]
[[-2, 2, 2], [-1, 2, 2], [-2, 3, 2], [-2, 2, 1]]
best sol： -2 [-2, 2, 2]


可以看到，最優解是-2，對應的x1、x2、x3分別取值-2、2、2。

三、如何找到全域性最優

爬山法獲取的最優解的可能是區域性最優，如果要獲得更好的解，多次使用爬山演算法（需要從不同的初始解開始爬山），從多個區域性最優解中找出最優解，而這個最優解也有可能是全域性最優解。


四、心得

爬山演算基本上就是將任何可能性都實際探索的窮舉法，倘若今日探索的山只是公園沙堆的小山，大部分的人都會覺得沒什麼，

倘若今日將要探索的是喜馬拉雅山，那般耗力費時想而知，此時方能明白，為了節省簡單卻龐大的人力資源便是人類發展機械的初衷啊。

五、參考

https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/374324/
